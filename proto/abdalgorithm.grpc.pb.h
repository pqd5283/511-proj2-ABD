// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: abdalgorithm.proto
#ifndef GRPC_abdalgorithm_2eproto__INCLUDED
#define GRPC_abdalgorithm_2eproto__INCLUDED

#include "abdalgorithm.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace abd {

class ClientRead final {
 public:
  static constexpr char const* service_full_name() {
    return "abd.ClientRead";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status SendRead(::grpc::ClientContext* context, const ::abd::read_request& request, ::abd::read_reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_reply>> AsyncSendRead(::grpc::ClientContext* context, const ::abd::read_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_reply>>(AsyncSendReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_reply>> PrepareAsyncSendRead(::grpc::ClientContext* context, const ::abd::read_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_reply>>(PrepareAsyncSendReadRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void SendRead(::grpc::ClientContext* context, const ::abd::read_request* request, ::abd::read_reply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendRead(::grpc::ClientContext* context, const ::abd::read_request* request, ::abd::read_reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_reply>* AsyncSendReadRaw(::grpc::ClientContext* context, const ::abd::read_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_reply>* PrepareAsyncSendReadRaw(::grpc::ClientContext* context, const ::abd::read_request& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status SendRead(::grpc::ClientContext* context, const ::abd::read_request& request, ::abd::read_reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::read_reply>> AsyncSendRead(::grpc::ClientContext* context, const ::abd::read_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::read_reply>>(AsyncSendReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::read_reply>> PrepareAsyncSendRead(::grpc::ClientContext* context, const ::abd::read_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::read_reply>>(PrepareAsyncSendReadRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SendRead(::grpc::ClientContext* context, const ::abd::read_request* request, ::abd::read_reply* response, std::function<void(::grpc::Status)>) override;
      void SendRead(::grpc::ClientContext* context, const ::abd::read_request* request, ::abd::read_reply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::abd::read_reply>* AsyncSendReadRaw(::grpc::ClientContext* context, const ::abd::read_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::abd::read_reply>* PrepareAsyncSendReadRaw(::grpc::ClientContext* context, const ::abd::read_request& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SendRead_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SendRead(::grpc::ServerContext* context, const ::abd::read_request* request, ::abd::read_reply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SendRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendRead() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SendRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendRead(::grpc::ServerContext* /*context*/, const ::abd::read_request* /*request*/, ::abd::read_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendRead(::grpc::ServerContext* context, ::abd::read_request* request, ::grpc::ServerAsyncResponseWriter< ::abd::read_reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SendRead<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SendRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendRead() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::abd::read_request, ::abd::read_reply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::abd::read_request* request, ::abd::read_reply* response) { return this->SendRead(context, request, response); }));}
    void SetMessageAllocatorFor_SendRead(
        ::grpc::MessageAllocator< ::abd::read_request, ::abd::read_reply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::abd::read_request, ::abd::read_reply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendRead(::grpc::ServerContext* /*context*/, const ::abd::read_request* /*request*/, ::abd::read_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendRead(
      ::grpc::CallbackServerContext* /*context*/, const ::abd::read_request* /*request*/, ::abd::read_reply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_SendRead<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SendRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendRead() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SendRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendRead(::grpc::ServerContext* /*context*/, const ::abd::read_request* /*request*/, ::abd::read_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendRead() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SendRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendRead(::grpc::ServerContext* /*context*/, const ::abd::read_request* /*request*/, ::abd::read_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendRead(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendRead() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendRead(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendRead(::grpc::ServerContext* /*context*/, const ::abd::read_request* /*request*/, ::abd::read_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendRead(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendRead : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendRead() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::abd::read_request, ::abd::read_reply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::abd::read_request, ::abd::read_reply>* streamer) {
                       return this->StreamedSendRead(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendRead() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendRead(::grpc::ServerContext* /*context*/, const ::abd::read_request* /*request*/, ::abd::read_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendRead(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::abd::read_request,::abd::read_reply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SendRead<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SendRead<Service > StreamedService;
};

class ClientReadWriteback final {
 public:
  static constexpr char const* service_full_name() {
    return "abd.ClientReadWriteback";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status SendReadWriteback(::grpc::ClientContext* context, const ::abd::read_writeback& request, ::abd::read_writeback_reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_writeback_reply>> AsyncSendReadWriteback(::grpc::ClientContext* context, const ::abd::read_writeback& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_writeback_reply>>(AsyncSendReadWritebackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_writeback_reply>> PrepareAsyncSendReadWriteback(::grpc::ClientContext* context, const ::abd::read_writeback& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_writeback_reply>>(PrepareAsyncSendReadWritebackRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void SendReadWriteback(::grpc::ClientContext* context, const ::abd::read_writeback* request, ::abd::read_writeback_reply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendReadWriteback(::grpc::ClientContext* context, const ::abd::read_writeback* request, ::abd::read_writeback_reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_writeback_reply>* AsyncSendReadWritebackRaw(::grpc::ClientContext* context, const ::abd::read_writeback& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::abd::read_writeback_reply>* PrepareAsyncSendReadWritebackRaw(::grpc::ClientContext* context, const ::abd::read_writeback& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status SendReadWriteback(::grpc::ClientContext* context, const ::abd::read_writeback& request, ::abd::read_writeback_reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::read_writeback_reply>> AsyncSendReadWriteback(::grpc::ClientContext* context, const ::abd::read_writeback& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::read_writeback_reply>>(AsyncSendReadWritebackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::read_writeback_reply>> PrepareAsyncSendReadWriteback(::grpc::ClientContext* context, const ::abd::read_writeback& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::read_writeback_reply>>(PrepareAsyncSendReadWritebackRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SendReadWriteback(::grpc::ClientContext* context, const ::abd::read_writeback* request, ::abd::read_writeback_reply* response, std::function<void(::grpc::Status)>) override;
      void SendReadWriteback(::grpc::ClientContext* context, const ::abd::read_writeback* request, ::abd::read_writeback_reply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::abd::read_writeback_reply>* AsyncSendReadWritebackRaw(::grpc::ClientContext* context, const ::abd::read_writeback& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::abd::read_writeback_reply>* PrepareAsyncSendReadWritebackRaw(::grpc::ClientContext* context, const ::abd::read_writeback& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SendReadWriteback_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SendReadWriteback(::grpc::ServerContext* context, const ::abd::read_writeback* request, ::abd::read_writeback_reply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SendReadWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendReadWriteback() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SendReadWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendReadWriteback(::grpc::ServerContext* /*context*/, const ::abd::read_writeback* /*request*/, ::abd::read_writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendReadWriteback(::grpc::ServerContext* context, ::abd::read_writeback* request, ::grpc::ServerAsyncResponseWriter< ::abd::read_writeback_reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SendReadWriteback<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SendReadWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendReadWriteback() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::abd::read_writeback, ::abd::read_writeback_reply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::abd::read_writeback* request, ::abd::read_writeback_reply* response) { return this->SendReadWriteback(context, request, response); }));}
    void SetMessageAllocatorFor_SendReadWriteback(
        ::grpc::MessageAllocator< ::abd::read_writeback, ::abd::read_writeback_reply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::abd::read_writeback, ::abd::read_writeback_reply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendReadWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendReadWriteback(::grpc::ServerContext* /*context*/, const ::abd::read_writeback* /*request*/, ::abd::read_writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendReadWriteback(
      ::grpc::CallbackServerContext* /*context*/, const ::abd::read_writeback* /*request*/, ::abd::read_writeback_reply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_SendReadWriteback<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SendReadWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendReadWriteback() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SendReadWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendReadWriteback(::grpc::ServerContext* /*context*/, const ::abd::read_writeback* /*request*/, ::abd::read_writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendReadWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendReadWriteback() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SendReadWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendReadWriteback(::grpc::ServerContext* /*context*/, const ::abd::read_writeback* /*request*/, ::abd::read_writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendReadWriteback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendReadWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendReadWriteback() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendReadWriteback(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendReadWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendReadWriteback(::grpc::ServerContext* /*context*/, const ::abd::read_writeback* /*request*/, ::abd::read_writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendReadWriteback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendReadWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendReadWriteback() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::abd::read_writeback, ::abd::read_writeback_reply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::abd::read_writeback, ::abd::read_writeback_reply>* streamer) {
                       return this->StreamedSendReadWriteback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendReadWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendReadWriteback(::grpc::ServerContext* /*context*/, const ::abd::read_writeback* /*request*/, ::abd::read_writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendReadWriteback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::abd::read_writeback,::abd::read_writeback_reply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SendReadWriteback<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SendReadWriteback<Service > StreamedService;
};

class ClientWrite final {
 public:
  static constexpr char const* service_full_name() {
    return "abd.ClientWrite";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status SendWrite(::grpc::ClientContext* context, const ::abd::write_request& request, ::abd::write_reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::write_reply>> AsyncSendWrite(::grpc::ClientContext* context, const ::abd::write_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::write_reply>>(AsyncSendWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::write_reply>> PrepareAsyncSendWrite(::grpc::ClientContext* context, const ::abd::write_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::write_reply>>(PrepareAsyncSendWriteRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void SendWrite(::grpc::ClientContext* context, const ::abd::write_request* request, ::abd::write_reply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendWrite(::grpc::ClientContext* context, const ::abd::write_request* request, ::abd::write_reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::abd::write_reply>* AsyncSendWriteRaw(::grpc::ClientContext* context, const ::abd::write_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::abd::write_reply>* PrepareAsyncSendWriteRaw(::grpc::ClientContext* context, const ::abd::write_request& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status SendWrite(::grpc::ClientContext* context, const ::abd::write_request& request, ::abd::write_reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::write_reply>> AsyncSendWrite(::grpc::ClientContext* context, const ::abd::write_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::write_reply>>(AsyncSendWriteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::write_reply>> PrepareAsyncSendWrite(::grpc::ClientContext* context, const ::abd::write_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::write_reply>>(PrepareAsyncSendWriteRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SendWrite(::grpc::ClientContext* context, const ::abd::write_request* request, ::abd::write_reply* response, std::function<void(::grpc::Status)>) override;
      void SendWrite(::grpc::ClientContext* context, const ::abd::write_request* request, ::abd::write_reply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::abd::write_reply>* AsyncSendWriteRaw(::grpc::ClientContext* context, const ::abd::write_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::abd::write_reply>* PrepareAsyncSendWriteRaw(::grpc::ClientContext* context, const ::abd::write_request& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SendWrite_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SendWrite(::grpc::ServerContext* context, const ::abd::write_request* request, ::abd::write_reply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendWrite() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendWrite(::grpc::ServerContext* /*context*/, const ::abd::write_request* /*request*/, ::abd::write_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendWrite(::grpc::ServerContext* context, ::abd::write_request* request, ::grpc::ServerAsyncResponseWriter< ::abd::write_reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SendWrite<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendWrite() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::abd::write_request, ::abd::write_reply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::abd::write_request* request, ::abd::write_reply* response) { return this->SendWrite(context, request, response); }));}
    void SetMessageAllocatorFor_SendWrite(
        ::grpc::MessageAllocator< ::abd::write_request, ::abd::write_reply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::abd::write_request, ::abd::write_reply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendWrite(::grpc::ServerContext* /*context*/, const ::abd::write_request* /*request*/, ::abd::write_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::abd::write_request* /*request*/, ::abd::write_reply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_SendWrite<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendWrite() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendWrite(::grpc::ServerContext* /*context*/, const ::abd::write_request* /*request*/, ::abd::write_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendWrite() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendWrite(::grpc::ServerContext* /*context*/, const ::abd::write_request* /*request*/, ::abd::write_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendWrite(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendWrite() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendWrite(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendWrite(::grpc::ServerContext* /*context*/, const ::abd::write_request* /*request*/, ::abd::write_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendWrite(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendWrite : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendWrite() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::abd::write_request, ::abd::write_reply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::abd::write_request, ::abd::write_reply>* streamer) {
                       return this->StreamedSendWrite(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendWrite() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendWrite(::grpc::ServerContext* /*context*/, const ::abd::write_request* /*request*/, ::abd::write_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendWrite(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::abd::write_request,::abd::write_reply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SendWrite<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SendWrite<Service > StreamedService;
};

class ClientWriteback final {
 public:
  static constexpr char const* service_full_name() {
    return "abd.ClientWriteback";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status SendWriteback(::grpc::ClientContext* context, const ::abd::writeback_request& request, ::abd::writeback_reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::writeback_reply>> AsyncSendWriteback(::grpc::ClientContext* context, const ::abd::writeback_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::writeback_reply>>(AsyncSendWritebackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::writeback_reply>> PrepareAsyncSendWriteback(::grpc::ClientContext* context, const ::abd::writeback_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::writeback_reply>>(PrepareAsyncSendWritebackRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void SendWriteback(::grpc::ClientContext* context, const ::abd::writeback_request* request, ::abd::writeback_reply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendWriteback(::grpc::ClientContext* context, const ::abd::writeback_request* request, ::abd::writeback_reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::abd::writeback_reply>* AsyncSendWritebackRaw(::grpc::ClientContext* context, const ::abd::writeback_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::abd::writeback_reply>* PrepareAsyncSendWritebackRaw(::grpc::ClientContext* context, const ::abd::writeback_request& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status SendWriteback(::grpc::ClientContext* context, const ::abd::writeback_request& request, ::abd::writeback_reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::writeback_reply>> AsyncSendWriteback(::grpc::ClientContext* context, const ::abd::writeback_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::writeback_reply>>(AsyncSendWritebackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::writeback_reply>> PrepareAsyncSendWriteback(::grpc::ClientContext* context, const ::abd::writeback_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::writeback_reply>>(PrepareAsyncSendWritebackRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SendWriteback(::grpc::ClientContext* context, const ::abd::writeback_request* request, ::abd::writeback_reply* response, std::function<void(::grpc::Status)>) override;
      void SendWriteback(::grpc::ClientContext* context, const ::abd::writeback_request* request, ::abd::writeback_reply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::abd::writeback_reply>* AsyncSendWritebackRaw(::grpc::ClientContext* context, const ::abd::writeback_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::abd::writeback_reply>* PrepareAsyncSendWritebackRaw(::grpc::ClientContext* context, const ::abd::writeback_request& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SendWriteback_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status SendWriteback(::grpc::ServerContext* context, const ::abd::writeback_request* request, ::abd::writeback_reply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SendWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendWriteback() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SendWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendWriteback(::grpc::ServerContext* /*context*/, const ::abd::writeback_request* /*request*/, ::abd::writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendWriteback(::grpc::ServerContext* context, ::abd::writeback_request* request, ::grpc::ServerAsyncResponseWriter< ::abd::writeback_reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SendWriteback<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SendWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendWriteback() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::abd::writeback_request, ::abd::writeback_reply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::abd::writeback_request* request, ::abd::writeback_reply* response) { return this->SendWriteback(context, request, response); }));}
    void SetMessageAllocatorFor_SendWriteback(
        ::grpc::MessageAllocator< ::abd::writeback_request, ::abd::writeback_reply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::abd::writeback_request, ::abd::writeback_reply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendWriteback(::grpc::ServerContext* /*context*/, const ::abd::writeback_request* /*request*/, ::abd::writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendWriteback(
      ::grpc::CallbackServerContext* /*context*/, const ::abd::writeback_request* /*request*/, ::abd::writeback_reply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_SendWriteback<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SendWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendWriteback() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SendWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendWriteback(::grpc::ServerContext* /*context*/, const ::abd::writeback_request* /*request*/, ::abd::writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendWriteback() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SendWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendWriteback(::grpc::ServerContext* /*context*/, const ::abd::writeback_request* /*request*/, ::abd::writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendWriteback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendWriteback() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendWriteback(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendWriteback(::grpc::ServerContext* /*context*/, const ::abd::writeback_request* /*request*/, ::abd::writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendWriteback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendWriteback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendWriteback() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::abd::writeback_request, ::abd::writeback_reply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::abd::writeback_request, ::abd::writeback_reply>* streamer) {
                       return this->StreamedSendWriteback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendWriteback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendWriteback(::grpc::ServerContext* /*context*/, const ::abd::writeback_request* /*request*/, ::abd::writeback_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendWriteback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::abd::writeback_request,::abd::writeback_reply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SendWriteback<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SendWriteback<Service > StreamedService;
};

class GetLock final {
 public:
  static constexpr char const* service_full_name() {
    return "abd.GetLock";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status AcquireLock(::grpc::ClientContext* context, const ::abd::lock_request& request, ::abd::lock_reply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::lock_reply>> AsyncAcquireLock(::grpc::ClientContext* context, const ::abd::lock_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::lock_reply>>(AsyncAcquireLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::lock_reply>> PrepareAsyncAcquireLock(::grpc::ClientContext* context, const ::abd::lock_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::abd::lock_reply>>(PrepareAsyncAcquireLockRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void AcquireLock(::grpc::ClientContext* context, const ::abd::lock_request* request, ::abd::lock_reply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AcquireLock(::grpc::ClientContext* context, const ::abd::lock_request* request, ::abd::lock_reply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::abd::lock_reply>* AsyncAcquireLockRaw(::grpc::ClientContext* context, const ::abd::lock_request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::abd::lock_reply>* PrepareAsyncAcquireLockRaw(::grpc::ClientContext* context, const ::abd::lock_request& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status AcquireLock(::grpc::ClientContext* context, const ::abd::lock_request& request, ::abd::lock_reply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::lock_reply>> AsyncAcquireLock(::grpc::ClientContext* context, const ::abd::lock_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::lock_reply>>(AsyncAcquireLockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::lock_reply>> PrepareAsyncAcquireLock(::grpc::ClientContext* context, const ::abd::lock_request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::abd::lock_reply>>(PrepareAsyncAcquireLockRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void AcquireLock(::grpc::ClientContext* context, const ::abd::lock_request* request, ::abd::lock_reply* response, std::function<void(::grpc::Status)>) override;
      void AcquireLock(::grpc::ClientContext* context, const ::abd::lock_request* request, ::abd::lock_reply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::abd::lock_reply>* AsyncAcquireLockRaw(::grpc::ClientContext* context, const ::abd::lock_request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::abd::lock_reply>* PrepareAsyncAcquireLockRaw(::grpc::ClientContext* context, const ::abd::lock_request& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_AcquireLock_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status AcquireLock(::grpc::ServerContext* context, const ::abd::lock_request* request, ::abd::lock_reply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_AcquireLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AcquireLock() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_AcquireLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AcquireLock(::grpc::ServerContext* /*context*/, const ::abd::lock_request* /*request*/, ::abd::lock_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAcquireLock(::grpc::ServerContext* context, ::abd::lock_request* request, ::grpc::ServerAsyncResponseWriter< ::abd::lock_reply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_AcquireLock<Service > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_AcquireLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AcquireLock() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::abd::lock_request, ::abd::lock_reply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::abd::lock_request* request, ::abd::lock_reply* response) { return this->AcquireLock(context, request, response); }));}
    void SetMessageAllocatorFor_AcquireLock(
        ::grpc::MessageAllocator< ::abd::lock_request, ::abd::lock_reply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::abd::lock_request, ::abd::lock_reply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AcquireLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AcquireLock(::grpc::ServerContext* /*context*/, const ::abd::lock_request* /*request*/, ::abd::lock_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AcquireLock(
      ::grpc::CallbackServerContext* /*context*/, const ::abd::lock_request* /*request*/, ::abd::lock_reply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_AcquireLock<Service > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_AcquireLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AcquireLock() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_AcquireLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AcquireLock(::grpc::ServerContext* /*context*/, const ::abd::lock_request* /*request*/, ::abd::lock_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_AcquireLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AcquireLock() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_AcquireLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AcquireLock(::grpc::ServerContext* /*context*/, const ::abd::lock_request* /*request*/, ::abd::lock_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAcquireLock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AcquireLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AcquireLock() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AcquireLock(context, request, response); }));
    }
    ~WithRawCallbackMethod_AcquireLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AcquireLock(::grpc::ServerContext* /*context*/, const ::abd::lock_request* /*request*/, ::abd::lock_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AcquireLock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AcquireLock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AcquireLock() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::abd::lock_request, ::abd::lock_reply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::abd::lock_request, ::abd::lock_reply>* streamer) {
                       return this->StreamedAcquireLock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AcquireLock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AcquireLock(::grpc::ServerContext* /*context*/, const ::abd::lock_request* /*request*/, ::abd::lock_reply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAcquireLock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::abd::lock_request,::abd::lock_reply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_AcquireLock<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_AcquireLock<Service > StreamedService;
};

}  // namespace abd


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_abdalgorithm_2eproto__INCLUDED
